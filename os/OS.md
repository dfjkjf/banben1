[TOC]

#进程和线程

概念|区别|通讯方式|不同通讯方式的区别优缺点
:---:|:---|:---|:---
进程是操作系统<br>进行资源分配和调度<br>的一个独立单元|每个进程都有独立的代码和数据空间<br>程序之间的切换会有较大的开销<br>每个进程分配不同的内存空间|管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET|管道（半双工、数据单项流动、亲缘关系的进程间）<br>命名管道（半双工、无亲缘关系的进程间通信）<br>信号量（计数器、控制多个进程对资源的访问、作为一种锁机制）<br>消息队列（消息的链表、存放在内核中并由消息队列标识符标识）<br>信号（通知接收进程某个事件已经发生）<br>共享内存（映射一段能被其它进程访问的内存）
线程是进程的实体<br>是CPU调度和执行的基本单位|同一类线程共享代码和数据空间<br>每个线程都有自己独立的运行栈和寄存器<br>线程之间切换的开销小<br>线程之间共享内存资源|线程间通信依靠访问临界资源|互斥量（互斥对象机制、只有拥有互斥对象的线程才有访问公共资源、独占）<br>信号量（允许多个线程访问同一资源、但是需要控制访问此资源的最大线程数量、限制）<br>事件（信号、通知接收线程某个事件已经发生、实现优先级）

**进程线程使用场景总结**
1. 需要频繁创建销毁的优先用线程
这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2. 需要进行大量计算的优先使用线程
所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是图像处理、算法处理。
3. 强相关的处理用线程，弱相关的处理用进程
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。
4. 可能要扩展到多机分布的用进程，多核分布的用线程

对比维度|多进程|多线程|总结
:---:|:---:|:---:|:---:
数据共享、同步|数据共享复杂，需要用IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势
内存、CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|线程占优
创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优
编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优
可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优
分布式|适应于多核、多机分布式<br>如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优

#孤儿进程与僵尸进程
孤儿进程：父进程退出，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)收养，并由init进程对它们完成状态收集工作。
僵尸进程：当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
在每个进程退出的时候，内核释放该进程所有的资源（打开的文件，占用的内存等）。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到父进程通过wait / waitpid来取时才释放。但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。此即为僵尸进程的危害，应当避免。
**避免僵尸进程的方法**
1. 父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。
2. 父进程用signal(SIGCHLD,SIG_IGN)通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收。
3. 直接在主进程里注册一个信号处理函数，用来接受处理子进程结束的信号.
4. 就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。

#死锁的产生与解决
通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。
死锁产生的四个条件（有一个条件不成立，则不会产生死锁）
+ 互斥条件：进程要求独占资源
+ 请求与保持条件：当进程因请求资源而阻塞时，对已获得资源保持不放
+ 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
+ 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

解决死锁的基本方法如下：
预防死锁、避免死锁、检测死锁、解除死锁
解决死锁的常用策略如下：
鸵鸟策略、预防策略、避免策略、检测与解除死锁

#CPU的执行方式

#代码中遇到进程阻塞，进程僵死，内存泄漏等情况怎么排查
进程阻塞：缺少资源
进程僵死：查找父进程，查找显示fork/隐式fork，
步骤：排查：ps -ef | **	--->    跟踪：strace -p 16634	--->    查看进程文件描述符目录：ll /proc/PID/fd	--->   
内存泄漏：内存泄漏一般指的是堆内存的泄漏。排查malloc,relloc,new。使用第三方工具

#有没有了解过协程？说下协程和线程的区别？

#堆是线程共有还是私有，堆是进程共有还是私有，栈呢
线程栈是私有的，保存其运行状态和局部变量。堆是共有的，在操作系统对进程初始化的时候分配；
进程堆栈都是私有的。

#了解过协程吗

#共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）
#c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）