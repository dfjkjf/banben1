[TOP]

#基础控件、用户自定义控件
#信号与槽（控件间的通信）
1. UI界面：旋转控件右击提升为槽
2. 在构造函数中连接信号与槽
`connect(谁发出信号ui->*，发出什么信号SINGAL()，谁处理信号this，怎么处理信号SLOT()); // 通过宏的形式`
3. 仿造信号槽
`connect(谁发出信号ui->*，发出什么信号&QPushButton::click()，谁处理信号this，怎么处理信号&Widget::on_pushButton_clicked()); // 取信号和槽的地址`
4. 当槽函数较小时，直接写槽函数
`connect(谁发出信号ui->*，发出什么信号&QPushButton::click()，[this](){QMessageBox::information(this,"信息","点击浏览")});`

#定时器
作用：延时
1. QObject：函数startTimer()开启定时器，TimeEvent()定时器事件，KillTimer()
2. QTimer：头文件QTimer，`QTimer *timer = new QTimer;timer->start();timer->stop();`
显示图片

#读写文件
getOpenFileName

#网络
服务器QTcpServer、客户端QTcpSocket

#多线程
#数据库

1、QT信号槽机制的优缺点 
1）QT信号槽机制的引用精简了程序员的代码量 
2）QT的信号可以对应多个槽（但他们的调用顺序随机），也可以多个槽映射一个信号 
3）QT的信号槽的建立和解除绑定十分自由 
4）信号槽同真正的回调函数比起来时间的耗损还是很大的，所有在嵌入式实时系统中应当慎用 
5）信号槽的参数限定很多例如不能携带模板类参数，不能出现宏定义等等

2、（1） 描述过程, 如何实现一个自定义按钮, 使其在光标进入,按下,离开三种状态下显示不同的图片. 
创建一个类, 让其从QPushButton类派生, 重写该类中的事件处理器函数 
1>. enterEvent() – 光标进入 
2>. leaveEvent() – 光标离开 
3>. mousePressEvent() – 鼠标按下 
4>. paintEvent() – 刷新背景图 
在每个事件中切换不同的图片, 通过paintEvent函数将新的图片刷新到按钮上 
手动刷新函数: update() 
（2） 描述在MFC视图窗口中, 单击鼠标右键如何弹出一个右键菜单? 
1. 在视图窗口中添加鼠标右键的消息处理函数 
2. 创建并实例化一个菜单对象 
3. 调用CMenu类的TrackPopupMenu函数显示右键菜单 
4. 给菜单项添加事件处理函数

3、多线程情况下, Qt中的信号槽分别在什么线程中执行, 如何控制? 
可以通过connect函数的第五个参数来控制, 信号槽执行时所在的线程 
1>. 直接连接 – 信号槽函数在信号发出者所在线程中执行 
2>. 队列连接 – 信号在信号发出者所在线程中执行,槽函数在信号接收者所在线程中执行. 
3>. 自动连接 – 多线程时为队列连接方式, 单线程时为直接连接方式 
默认情况为自动连接方式.

4、描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别, 他们都能帮助我们完成一些什么事情. 
QTextStream – 文本流, 操作轻量级数据(int, double, QString), 数据写入文件中之后以文本的方式呈现。 
QDataStream – 数据流, 通过数据流可以操作各种数据类型, 包括类对象, 存储到文件中数据可以还原到内存。 
QTextStream, QDataStream可以操作磁盘文件, 也可以操作内存数据, 通过流对象可以将数据打包到内存, 进行数据的传输.

5、描述Qt下Tcp通信的整个流程 
服务器端: 
1. 创建用于监听的套接字 
2. 给套接字设置监听 
3. 如果有连接到来, 监听的套接字会发出信号newConnected 
4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信) 
5. 使用用于通信的套接字对象通信 
1>. 发送数据: write 
2>. 接收数据: readAll/read 
客户端: 
1. 创建用于通信的套接字 
2. 连接服务器: connectToHost 
3. 连接成功与服务器通信 
1>. 发送数据: write 
2>. 接收数据: readAll/read

6、（1） 描述QT下udp通信的整个流程 
QT下udp通信服务器端和客户端的关系是对等的, 做的处理也是一样的. 
1. 创建套接字对象 
2. 如果需要接收数据, 必须绑定端口 
3. 发送数据: writeDatagram 
4. 接收数据: readDatagram 
（2） 描述QT下多线程的两种使用方法, 以及注意事项 
第一种方法: 
1. 创建一个类从QThread类派生 
2. 在子线程类中重写 run 函数, 将处理操作写入该函数中 
3. 在主线程中创建子线程对象, 启动子线程, 调用start()函数 
第二种方法: 
1. 将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数 
2. 在主线程中创建一QThread类对象 
3. 在主线程中创建一个业务类对象 
4. 将业务类对象移动到子线程中 
5. 在主线程中启动子线程 
6. 通过信号槽的方式, 执行业务类中的业务处理函数 
多线程使用注意事项: 
* 1. 业务对象, 构造的时候不能指定父对象 
* 2. 子线程中不能处理ui窗口(ui相关的类) 
* 3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口

7、描述Windows下一个消息从触发到处理的整个路由过程. 
应用程序启动, 操作系统为程序创建一个对应的消息队列, 用户对创建进行操作, 产生一系列消息, 
操作系统首先捕捉到这些消息, 将消息投递到对应的消息队列中, 在应用程序中对应一个消息循环 
消息循环每次从消息队列中取出消息, 取出的消息如果是虚拟键消息, 会将其转换成标准消息, 将 
转换的消息再次投递到消息队列, 如果取出的是标准消息, 会将该消息发送给操作系统, 操作系统 
会调用对应的窗口过程函数, 下窗口过程函数中对对用的消息进程处理.

12、QT如果要进行网络编程首先需要在.pro中添加如下代码：QT += network 
在头文件中包含相关头文件 
#include <QHostInfo>
#include <QNetworkInterface>

2、QT的UdpSocket接收消息使用原则 
第一步：new一个UdpSocket 
第二步：调用UdpSocket的bind方法，同时指定端口号 
第三步：使用connect将接收消息函数和UdpSocket对象做关联 
第四步：在接受消息槽函数当中调用readDatagram接收消息

